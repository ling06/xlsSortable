"use strict";
var XlsSortable = function XlsSortable(selector, options) {
  options = Object.assign({ autostart: !0 }, options || {});var guessFunctions = [function (value, column) {
    return !!/^\d+[.\-\/]\d+[.\-\/]\d+ \d+:\d+(:\d+)?$/.test(value) && "datetime";
  }, function (value, column) {
    return !!/^\d+[.\-\/]\d+[.\-\/]\d+$/.test(value) && "date";
  }, function (value, column) {
    return !!/^\d+:\d+(:\d+)?$/.test(value) && "time";
  }, function (value, column) {
    return !isNaN(parseFloat(value)) && "number";
  }, function (value, column) {
    return "string";
  }],
      sortFunctions = { datetime: function datetime(a, b, sortDir) {
      return a = a.replace(/(\d+)[.\/\-](\d+)[.\/\-](\d+)/, "$3-$2-$1"), b = b.replace(/(\d+)[.\/\-](\d+)[.\/\-](\d+)/, "$3-$2-$1"), "asc" === sortDir && a > b || "desc" === sortDir && a < b ? 1 : "asc" === sortDir && a < b || "desc" === sortDir && a > b ? -1 : 0;
    }, date: function date(a, b, sortDir) {
      return a = a.replace(/(\d+)[.\/\-](\d+)[.\/\-](\d+)/, "$3-$2-$1"), b = b.replace(/(\d+)[.\/\-](\d+)[.\/\-](\d+)/, "$3-$2-$1"), "asc" === sortDir && a > b || "desc" === sortDir && a < b ? 1 : "asc" === sortDir && a < b || "desc" === sortDir && a > b ? -1 : 0;
    }, time: function time(a, b, sortDir) {
      return "asc" === sortDir && a > b || "desc" === sortDir && a < b ? 1 : "asc" === sortDir && a < b || "desc" === sortDir && a > b ? -1 : 0;
    }, number: function number(a, b, sortDir) {
      return a = parseFloat(a), b = parseFloat(b), "asc" === sortDir && a > b || "desc" === sortDir && a < b ? 1 : "asc" === sortDir && a < b || "desc" === sortDir && a > b ? -1 : 0;
    }, string: function string(a, b, sortDir) {
      return "asc" === sortDir && a > b || "desc" === sortDir && a < b ? 1 : "asc" === sortDir && a < b || "desc" === sortDir && a > b ? -1 : 0;
    } },
      printFunctions = { datetime: function datetime(value) {
      return (/(\d+)\-(\d+)\-(\d+)/.test(value) && (value = value.replace(/(\d+)\-(\d+)\-(\d+)/, "$3.$2.$1")), /\d+\/\d+\/\d+/.test(value) && (value = value.split("/").join(".")), value
      );
    }, date: function date(value) {
      return (/\d+\-\d+\-\d+/.test(value) ? value.split("-").reverse().join(".") : /\d+\/\d+\/\d+/.test(value) ? value.split("/").join(".") : value
      );
    }, time: function time(value) {
      return value;
    }, number: function number(value) {
      return value;
    }, string: function string(value) {
      return value;
    } },
      queue = [],
      parseExcel = function parseExcel(file, callback) {
    var reader = new FileReader();reader.onload = function (event) {
      var data = event.target.result,
          workbook = XLSX.read(data, { type: "binary" });workbook.SheetNames.forEach(function (sheetName) {
        var XLRowObject = XLSX.utils.sheet_to_row_object_array(workbook.Sheets[sheetName]);"function" == typeof callback && callback(XLRowObject);
      });
    }, reader.onerror = function (ex) {
      console.log(ex);
    }, reader.readAsBinaryString(file);
  };function loadScript(url, callback) {
    var head = document.head,
        script = document.createElement("script");script.type = "text/javascript", script.src = url, script.onreadystatechange = callback, script.onload = callback, head.appendChild(script);
  }function numToRow(num, str) {
    str = str || "";var codeA = "A".charCodeAt(0),
        code = num % 26;return str = String.fromCharCode(codeA + code) + str, (num -= code) ? numToRow(num / 26 - 1, str) : str;
  }function guessType(value, column) {
    for (var i = 0, il = guessFunctions.length; i < il; ++i) {
      var type = guessFunctions[i](value, column);if (type) return type;
    }return "string";
  }function sortData(data, sortBy, sortDir) {
    return data.body = data.body.sort(function (a, b) {
      if (void 0 !== data.minValues[sortBy]) {
        if (a[sortBy] === data.minValues[sortBy] && b[sortBy] !== data.minValues[sortBy]) return "asc" === sortDir ? -1 : 1;if (a[sortBy] !== data.minValues[sortBy] && b[sortBy] === data.minValues[sortBy]) return "asc" === sortDir ? 1 : -1;if (a[sortBy] === data.minValues[sortBy] && b[sortBy] === data.minValues[sortBy]) return 0;
      }if (void 0 !== data.maxValues[sortBy]) {
        if (a[sortBy] === data.maxValues[sortBy] && b[sortBy] !== data.maxValues[sortBy]) return "asc" === sortDir ? 1 : -1;if (a[sortBy] !== data.maxValues[sortBy] && b[sortBy] === data.maxValues[sortBy]) return "asc" === sortDir ? -1 : 1;if (a[sortBy] === data.maxValues[sortBy] && b[sortBy] === data.maxValues[sortBy]) return 0;
      }return sortFunctions[data.types[sortBy]](a[sortBy], b[sortBy], sortDir);
    }), data.body;
  }function fireEvent(event, options) {
    "function" == typeof options[event] && options[event].call(this, options);
  }function processTable(selector, options) {
    if (void 0 !== (options = Object.assign({ tableClass: "xlsSortable-table", tableSortClass: "xlsSortable-sortable", theme: !1 }, options || {})).guessFunctions && options.guessFunctions.reverse().forEach(function (guessFunction) {
      "function" == typeof guessFunction && guessFunctions.unshift(guessFunction);
    }), void 0 !== options.sortFunctions && Object.assign(sortFunctions, options.sortFunctions), void 0 !== options.printFunctions && Object.assign(printFunctions, options.printFunctions), "undefined" == typeof XLSX) return queue.push([selector, options]), !0;if (void 0 !== selector) if ("string" == typeof selector) {
      var elements = document.querySelectorAll(selector);elements && elements.forEach(function (element) {
        processTable(element, options);
      });
    } else {
      var tableOptions = Object.assign(options, selector.dataset);"string" == typeof tableOptions.noSort && (tableOptions.noSort = tableOptions.noSort.toUpperCase().split(",")), tableOptions.el = selector, url = options.file, callback = function callback(XLSobject) {
        var tableData = { headers: [], body: [], types: [], minValues: [], maxValues: [] },
            typesCount = [];if (XLSobject[0]) for (var header in XLSobject[0]) {
          XLSobject[0].hasOwnProperty(header) && (tableData.headers.push(header), typesCount[header] = {});
        }for (var i in XLSobject.forEach(function (dataRow) {
          var row = [];for (var i in dataRow) {
            row.push(void 0 !== dataRow[i] ? dataRow[i] : "");var type = guessType(dataRow[i], i);void 0 === typesCount[i][type] && (typesCount[i][type] = 0), ++typesCount[i][type];
          }tableData.body.push(row);
        }), typesCount) {
          var col = tableData.types.length,
              colName = numToRow(col),
              optionType = "type" + colName,
              optionMinValue = "minValue" + colName,
              optionMaxValue = "maxValue" + colName;if (void 0 !== options[optionType]) tableData.types.push(options[optionType]);else {
            var maxType = { type: "", count: 0 };for (var type in typesCount[i]) {
              typesCount[i][type] > maxType.count && (maxType.type = type, maxType.count = typesCount[i][type]);
            }tableData.types.push(maxType.type);
          }void 0 !== options[optionMinValue] && (tableData.minValues[col] = options[optionMinValue]), void 0 !== options[optionMaxValue] && (tableData.maxValues[col] = options[optionMaxValue]);
        }tableData.body.forEach(function (dataRow, i) {
          dataRow.forEach(function (dataCell, j) {
            tableData.body[i][j] = printFunctions[tableData.types[j]](dataCell);
          });
        }), function formTable(tableElement, tableData, options) {
          -1 !== (options = Object.assign({ sortBy: -1, sortDir: "" }, options || {})).sortBy && options.sortDir && (tableData.body = sortData(tableData, options.sortBy, options.sortDir));var table = document.createElement("table");table.classList.add(options.tableClass), options.theme && table.classList.add(options.tableClass + "_theme_" + options.theme);for (var thead = document.createElement("thead"), theadTr = document.createElement("tr"), _loop = function _loop(i, il) {
            var th = document.createElement("th"),
                colName = numToRow(i);(void 0 === options.noSort || -1 === options.noSort.indexOf(colName)) && (th.classList.add(options.tableSortClass), options.sortBy === i && th.classList.add(options.tableSortClass + "-" + options.sortDir), function (i) {
              th.addEventListener("click", function () {
                options.sortBy !== i ? options.sortDir = "asc" : options.sortDir = "asc" === options.sortDir ? "desc" : "asc", options.sortBy = i, sortData(tableData, options.sortBy, options.sortDir), formTable(tableElement, tableData, options), fireEvent("tableSorted", options);
              });
            }(i)), th.innerText = tableData.headers[i], theadTr.appendChild(th);
          }, i = 0, il = tableData.headers.length; i < il; ++i) {
            _loop(i);
          }thead.appendChild(theadTr), table.appendChild(thead);var tbody = document.createElement("tbody");for (tableData.body.forEach(function (row) {
            var tbodyTr = document.createElement("tr");row.forEach(function (cell) {
              var td = document.createElement("td");td.innerText = cell, tbodyTr.appendChild(td);
            }), tbody.appendChild(tbodyTr);
          }), table.appendChild(tbody); tableElement.firstChild;) {
            tableElement.removeChild(tableElement.firstChild);
          }tableElement.appendChild(table);
        }(selector, tableData, tableOptions), fireEvent("tableLoaded", tableOptions);
      }, fetch(url, { cache: "no-cache" }).then(function (response) {
        return response.blob();
      }).then(function (blob) {
        return parseExcel(blob, callback);
      });
    }var url, callback;
  }return loadScript("https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/jszip.js", function () {
    loadScript("https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.8.0/xlsx.js", function () {
      if (options.autostart && (function (selector, options) {
        processTable(selector = selector || ".xls-table", options = options || {});
      }(selector, options), queue.length)) for (var queueData = void 0; queueData = queue.pop();) {
        processTable(queueData[0], queueData[1]);
      }
    });
  }), { processTable: processTable };
};
//# sourceMappingURL=xlsSortable.min.js.map